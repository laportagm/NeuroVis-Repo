# Data Storage and Access Plan: AI-Enhanced Brain Anatomy Visualizer (Desktop)

**Version:** 0.1
**Date:** May 15, 2025
**Project Phase:** Initial Planning & Phase 1 Start
**Location:** Ardmore, Pennsylvania, United States

## 1. Introduction

This document outlines the strategy for storing and accessing various types of data required by the AI-Enhanced Brain Anatomy Visualizer desktop application. A clear plan ensures data is managed efficiently, securely (where applicable), and is accessible to the application as needed, particularly in a desktop environment that may operate offline for core features.

## 2. Types of Data

The application will handle the following primary data types:

1.  **3D Models:**
    - Description: Geometric data representing the brain and its structures.
    - Format: GLTF (.glb or .gltf) is preferred.
    - Source: Downloaded from open/free repositories, curated by the developer.
2.  **Anatomical Knowledge Base:**
    - Description: Textual and relational data about brain structures (names, descriptions, functions, connections, etc.).
    - Format: JSON initially (`anatomical_data.json`).
    - Source: Manually curated and verified by the developer.
3.  **Application Configuration (Future Consideration):**
    - Description: User-specific settings (e.g., window size/position, display preferences, last viewed model/structure).
    - Format: Likely JSON or a simple key-value store (e.g., INI-like format).
    - Source: Generated by the application based on user actions or defaults.
4.  **User-Generated Content (Future Consideration - Low Priority for MVP):**
    - Description: Annotations, saved views, learning progress if implemented.
    - Format: To be determined (could be JSON, SQLite).
    - Source: Created by the end-user.
5.  **Temporary/Cache Data (If Needed):**
    - Description: Data cached for performance, e.g., API responses for the in-app AI if caching is implemented.
    - Format: To be determined based on need.

## 3. Storage Mechanisms (Desktop Focus)

Given the desktop nature of the application, data will be stored locally on the user's machine.

- **A. Bundled Assets (Shipped with the Application):**

  - **Purpose:** For core application data that is essential for functionality and doesn't typically change per user installation (read-only after installation).
  - **Data Types:** 3D Models, initial Anatomical Knowledge Base JSON.
  - **Storage Method:** These files will be included directly in the application's installation package.
    - **Electron:** Assets are typically bundled into an `asar` archive (by tools like Electron Forge/Builder) or can be kept as loose files within the packaged application directory. They are accessed using relative paths from the application's root or specific Electron APIs like `app.getAppPath()` combined with `path.join()`.
    - **Godot Engine:** Assets are imported into the project and then packed into the exported game's data package (e.g., `.pck` file) or included in the exported project folder. They are accessed using Godot's resource path system, typically starting with `res://`.
  - **AI Assist Prompt Example:** "For my [Electron/Godot] desktop app, how do I correctly include a `brain_model.glb` file (located in my project's `assets/models/` folder) so that it's bundled with the final application and accessible at runtime? Show me the typical code to get its path."

- **B. Local User Directory (Per-User Data):**
  - **Purpose:** For storing data that is specific to the user or their instance of the application (e.g., configurations, future user-generated content). This data should persist between application sessions.
  - **Data Types:** Application Configuration, potentially User-Generated Content, AI API response cache.
  - **Storage Location:** Standard operating system locations for user-specific application data.
    - **Electron:** Use `app.getPath('userData')` to get the path to a directory dedicated to your application within the user's profile (e.g., `~/Library/Application Support/<YourAppName>` on macOS, `%APPDATA%\<YourAppName>` on Windows). Files can be created and managed here.
    - **Godot Engine:** Use `OS.get_user_data_dir()` which returns a path like `user://` that maps to the OS-specific user data location for your app.
  - **AI Assist Prompt Example:** "In my [Electron/Godot] app, I want to save a simple JSON configuration file (e.g., `settings.json`) that stores the last window size. How do I get the correct cross-platform path to the user-specific application data directory and then write/read this JSON file?"

## 4. Data Access Strategies

- **A. Reading Bundled Assets:**

  - **3D Models:**
    - **Electron/Three.js:** `GLTFLoader` will take a relative path (e.g., `./assets/models/brain_model.glb`) or an absolute path derived from `app.getAppPath()`.
    - **Godot:** Use `load("res://assets/models/brain_model.glb")` or `preload()` in GDScript to get a reference to the model scene/resource.
  - **Anatomical Knowledge Base (JSON):**
    - **Electron/JavaScript:**
      - In the main process: `const fs = require('fs'); const path = require('path'); const data = JSON.parse(fs.readFileSync(path.join(app.getAppPath(), 'assets/data/anatomical_data.json'), 'utf-8'));` (Then use IPC to send to renderer).
      - Alternatively, if treated as a static asset served to the renderer, `Workspace('./assets/data/anatomical_data.json').then(res => res.json())`.
    - **Godot/GDScript:**
      ```gdscript
      func load_anatomical_data():
          var file = FileAccess.open("res://assets/data/anatomical_data.json", FileAccess.READ)
          if file:
              var json_string = file.get_as_text()
              file.close()
              var parse_result = JSON.parse_string(json_string) # Godot 3.x
              # For Godot 4.x: var json_data = JSON.new(); json_data.parse(json_string); return json_data.get_data()
              if parse_result is GDScriptFunctionState: # Godot 3.x specific error check if JSON is huge
                  parse_result = yield(parse_result, "completed")
              if typeof(parse_result) == TYPE_DICTIONARY or typeof(parse_result) == TYPE_ARRAY:
                   return parse_result
              else:
                   printerr("Error parsing anatomical JSON: ", parse_result if typeof(parse_result) == TYPE_INT else "Unknown error") # Godot 3.x error code
                   return null
          else:
              printerr("Failed to open anatomical_data.json")
              return null
      ```
  - **AI Assist Prompt Example:** "Show me the [JavaScript code for Electron's main process / GDScript code for Godot] to read a JSON file named `config.json` from the bundled application assets and parse its content."

- **B. Reading/Writing to Local User Directory:**
  - **Application Configuration (e.g., JSON):**
    - Use standard file system operations (`fs.readFileSync`/`fs.writeFileSync` in Node.js for Electron; `FileAccess.open()` with `READ_WRITE` mode in Godot) combined with JSON parsing/stringifying.
    - Ensure paths are correctly resolved using `app.getPath('userData')` or `OS.get_user_data_dir()`.
  - **AI Assist Prompt Example:** "I need to save the current window dimensions to `settings.json` in the user data directory when my [Electron/Godot] app closes, and load them on startup. Provide the [JavaScript/GDScript] functions for saving and loading this JSON data."

## 5. Data Flow Examples

1.  **Application Startup:**
    - App launches.
    - Reads `anatomical_data.json` from bundled assets into an in-memory data structure (e.g., an array or dictionary).
    - (Future) Reads `settings.json` from the user data directory to restore window size/position.
2.  **User Selects 3D Model Part:**
    - Selection event occurs.
    - App uses the selected part's ID to look up information in the in-memory anatomical data structure.
    - Information is displayed in the UI.
3.  **User Interacts with In-App AI:**
    - User asks a question about the selected part.
    - App constructs a prompt, sends it to the online LLM API.
    - (Future) Response might be cached temporarily to a file in the user data directory to avoid repeated API calls for the same query in a short period.

## 6. Data Security & Integrity (Basic Considerations)

- **Bundled Data:** Considered read-only after installation. Integrity relies on the initial packaging.
- **User Directory Data:**
  - The application will have read/write access to its own data in the user directory.
  - No highly sensitive personal data is planned for storage in MVP/initial versions.
  - For configuration files, basic error handling during parsing (e.g., if the file is corrupted, load default settings) should be implemented.
- **No encryption planned for local files in MVP** due to complexity, as non-sensitive data is involved.

## 7. Scalability (Data Growth)

- **Anatomical Knowledge Base (JSON):**
  - For a few hundred to a couple of thousand entries, a single JSON file loaded into memory is generally acceptable.
  - If the knowledge base grows to many thousands of detailed entries or becomes highly relational (many complex connections), performance for loading, parsing, and querying the in-memory JSON might degrade.
  - **Future Consideration:** If significant scaling is needed, migrating the knowledge base to an embedded database like SQLite (bundled with the app or stored in the user directory) would be a more robust solution. This allows for indexed queries and avoids loading everything into memory. This is a significant step up in complexity from a JSON file.
- **3D Models:** Managed individually. Application performance will depend more on the complexity of the single model being viewed rather than the total number of available (but not loaded) models.
